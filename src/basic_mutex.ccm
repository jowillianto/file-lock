module;
#include <filesystem>
#include <mutex>
#include <sys/fcntl.h>
#include <unistd.h>
#include <sys/resource.h>
#include <shared_mutex>
#include <cerrno>
#include <system_error>
export module file_lock:basic_mutex;
import :shared_mutex;

namespace file_lock {
  export class BasicMutex {
    std::shared_mutex _mutex;
    std::filesystem::path _file_path;
    int _fd;

    void _throw_sys_error() {
      throw std::filesystem::filesystem_error{
        std::strerror(errno), 
        _file_path, 
        std::error_code{ errno, std::generic_category() }
      };
    }
    void _open_file_and_absol_path(int additional_flags) {
      _fd = open(
        _file_path.c_str(), O_CREAT | O_APPEND | O_RDONLY | additional_flags
      );
      if (_fd == -1) _throw_sys_error();
      _file_path = std::filesystem::absolute(_file_path);
    }
  public:
    BasicMutex(
      const std::filesystem::path& file_path, int additional_flags = 0
    ) : _file_path(file_path)
    {
      _open_file_and_absol_path(additional_flags);
    }
    BasicMutex(const std::string& file_path, int additional_flags = 0) : 
      _file_path(file_path) 
    {
      _open_file_and_absol_path(additional_flags);
    }
    void lock() {
      std::unique_lock lock { _mutex };
      int lock_st = flock(_fd, LOCK_EX);
      if (lock_st == -1) _throw_sys_error();
      lock.release();
    }
    void unlock() {
      int lock_st = flock(_fd, LOCK_UN);
      if (lock_st == -1) _throw_sys_error();
      _mutex.unlock();
    }
    bool try_lock() {
      if (!_mutex.try_lock())
        return false;
      int lock_st = flock(_fd, LOCK_EX | LOCK_NB);
      if (lock_st == -1) {
        _mutex.unlock();
        return false;
      }
      return true;
    }
    void lock_shared() {
      std::shared_lock lock {_mutex};
      int lock_st = flock(_fd, LOCK_SH);
      if (lock_st == -1) _throw_sys_error();
      lock.release();
    }
    void unlock_shared() {
      int lock_st = flock(_fd, LOCK_UN);
      if (lock_st == -1) _throw_sys_error();
      _mutex.unlock_shared();
    }
    bool try_lock_shared() {
      if (!_mutex.try_lock_shared())
        return false;
      int lock_st = flock(_fd, LOCK_SH | LOCK_NB);
      if (lock_st == -1) {
        _mutex.unlock_shared();
        return false;
      }
      return true;
    }
    const std::filesystem::path& protected_path() const {
      return _file_path;
    }
    std::string protected_path_string() const{
      return _file_path.string();
    }
    ~BasicMutex() {
      if (_fd != -1) {
        int close_st = close(_fd);
        if (close_st == -1) 
          _throw_sys_error();
      }
    }
  };

  static_assert (SharedMutex<BasicMutex>);
};