module;
#include <filesystem>
#include <cerrno>
#include <system_error>
#include <sys/fcntl.h>
#include <sys/resource.h>
#include <sys/stat.h>
#include <unistd.h>
export module file_lock:sys_file_lock;
import :shared_mutex;

namespace file_lock {
  export class SysFileLock{
    std::filesystem::path _file_path;
    int _fd;
    void _throw_sys_error() {
      throw std::filesystem::filesystem_error{
        std::strerror(errno),
        _file_path,
        std::error_code{errno, std::generic_category()}
      };
    }
    void _open_file_and_absol_path(int additional_flags) {
      if (!std::filesystem::exists(_file_path)){
        _fd = open(_file_path.c_str(), O_CREAT | O_RDWR, 0664);
        if (_fd == -1) _throw_sys_error();
        close(_fd);
      }
      _file_path = std::filesystem::absolute(_file_path);
      _fd = open(_file_path.c_str(), O_RDONLY);
      if (_fd == -1) _throw_sys_error();
    }
    public:
      SysFileLock(const std::filesystem::path& file_path) : 
        _file_path(file_path)
      {
        _open_file_and_absol_path(0);
      }
      SysFileLock(const std::string& file_path) : 
        _file_path(file_path)
      {
        _open_file_and_absol_path(0);
      }
      void lock() {
        int lock_st = flock(_fd, LOCK_EX);
        if (lock_st == -1) _throw_sys_error();
      }
      void unlock() {
        int lock_st = flock(_fd, LOCK_UN);
        if (lock_st == -1) _throw_sys_error();
      }
      bool try_lock() {
        int lock_st = flock(_fd, LOCK_EX | LOCK_NB);
        return lock_st != -1;
      }
      void lock_shared() {
        int lock_st = flock(_fd, LOCK_SH);
        if (lock_st == -1) _throw_sys_error();
      }
      void unlock_shared() {
        int lock_st = flock(_fd, LOCK_UN);
        if (lock_st == -1) _throw_sys_error();
      }
      bool try_lock_shared() {
        int lock_st = flock(_fd, LOCK_SH | LOCK_NB);
        return lock_st != -1;
      }
      const std::filesystem::path &protected_path() const {
        return _file_path;
      }
      std::string protected_path_string() const {
        return _file_path.string();
      }
      ~SysFileLock() {
        if (_fd != -1) {
          int close_st = close(_fd);
          if (close_st == -1) _throw_sys_error();
        }
      }

  };
  static_assert(SharedMutex<SysFileLock> );
}